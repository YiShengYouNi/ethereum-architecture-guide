# 我想：状态树与存储树

我这样理解：

| 判断 | 是否正确 | 说明 |
| --- | --- | --- |
| 状态树是全局唯一的 | ✅ 是 | 整个以太坊网络**仅维护一棵世界状态树**（World State Tree），跟随区块同步更新，代表全链状态 |
| 状态树随着账户增多而变大 | ✅ 是 | 每新增一个 EOA 或合约账户，都会在状态树中增加一个节点（键为地址，值为账户结构） |
| 每个合约账户都有一个独立的 storage trie | ✅ 是 | 合约账户的 `storageRoot` 字段就是其**私有存储树**的根哈希 |
| 以太坊中有多少个合约账户，就有多少个 storage trie | ✅ 是 | 每个合约账户对应 1 棵存储 Trie，彼此独立，由主状态树引用它的根 |

## 🧠 拓展理解：状态树与存储树的层级关系

我们可以这样来形象化它们的关系：

```
World State Tree（主状态树）
│
├── 0xaaa...123 （EOA） → { balance, nonce, ... }
├── 0xbbc...456 （CA）  → {
│       storageRoot → ⬅️ ⬇️ Storage Trie（该合约状态变量）
│       codeHash
│   }
├── 0xcde...789 （CA） → {
        storageRoot → ⬅️ ⬇️ 另一棵 Storage Trie
        ...
    }
...
```

> 📌 所有 storage trie 的根哈希都被挂在它所属的账户节点的 storageRoot 字段下，主状态树不保存子树的内容本体，只存储其入口。
> 

---

## 📦 存储空间负担的来源？

1. 🌍 **状态树的增长**：随着账户数量增多，主状态树体积不断增大（特别是频繁交互的账户）
2. 📂 **合约存储累积**：每个合约账户的 storage trie 如果变量多、历史变化频繁，也会使状态同步代价升高
3. 🧊 **历史状态冻结**：普通全节点只保存最新状态，**归档节点**才保留全部状态演进历史（极度占空间）